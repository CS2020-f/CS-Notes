### 闭包
闭包是指有权访问另一个函数作用域中的变量的函数；

常见闭包

```js
  function f() {
        let name='xim'
        return function b() {
            console.log(name)
        }

    }
    
   ```
    
 2.闭包的作用
正常函数执行完毕后,里面声明的变量被垃圾回收处理掉,但是闭包可以让作用域里的变量,在函数执行完之后依旧保持没有被垃圾回收处理掉

3.闭包的特性
外部的方法和变量就不会污染闭包内部的东西，同时，闭包内的变量也会有效的保存下来

```js

 function people(nameNew) {
       var name='小米'
       this.say=function() {
           alert(name)
       }
       this.update=function (nameNew) {
           this.name=nameNew
       }
   }
       var p=new people()
       p.say()//小米
       console.log(p.name)//undefined
       p.update('we')
       console.log(p.name)//we
       
  ```
  
  #### 闭包的实例
  1 返回函数
  // 创建闭包最常见的方式函数作为返回值
  
  ```js
  
<script>
    function f() {
        let name='xim'
        return function b() {
            console.log(name)
        }

    }
    setTimeout(()=>{
        f()
    },1000)
   function people(nameNew) {
       var name='小米'
       this.say=function() {
           alert(name)
       }
       this.update=function (nameNew) {
           this.name=nameNew
       }
   }
       var p=new people()
       p.say()//小米
       console.log(p.name)//undefined
       p.update('we')
       console.log(p.name)//we


   // 创建闭包最常见的方式函数作为返回值
   function f() {
       var name="we"
       return function () {
           console.log(name)
       }
   }
   var fun=f()
    fun() //外部函数访问内部变量

   //定时器问题
    for (var i=0;i<5;i++){
        setTimeout(()=>{
            console.log(i) //5 5 5 5 5
        },1000)
    }
    //setTimeout函数在当前执行队列的最后执行，获取到的i是最外部作用域的i=5,所以得到5个5

   //创建闭包
    for (var i=0;i<5;i++){
        setTimeout((
            function (i) {
                return function () {
                    console.log(i)//0 1 2 3 4
                }
            }
        )(i),1000)
    }

    //还可以通过将var改为let，这样for循环就拥有了块级作用域，也能解决这个问题
   for (let i=0;i<5;i++){
       setTimeout(()=>{
           console.log(i) //0 1 2 3 4
       },1000)
   }

   //使用多个计数器
   var count=0
    function addCount() {
        count+=1
        console.log(count)
    }
   var count1=0
    //....
    //使用闭包
    function addCount() {
       var count=0
        return function () {
           count+=1
            console.log(count)
        }
    }

   var f1=addCount()
    f1()
    f1()
    var f2 =addCount()
    f2()
    f2()
    1
    2
    1
    2
    
    ```
addCount() 执行的时候, 返回一个函数；   <br>
函数是可以创建自己的作用域的, 但是此时返回的这个函数内部需要引用 addCount() 作用域下的变量 count, 因此这个 count 是不能被销毁的；   <br>
接下来需要几个计数器我们就定义几个变量就可以，并且他们都不会互相影响，每个函数作用域中还会保存 count 变量不被销毁，进行不断的累加   <br>



由于闭包会常驻内存，使用不当会导致内存溢出
