作者：bbin
链接：https://www.nowcoder.com/discuss/513379
来源：牛客网
## 手撕题<br>
★★★：高频，很重要<br>
★★ ：中频，最好掌握<br>
★ ：了解即可<br>
### JS<br>

模拟实现函数的call、apply、bind方法    ★★<br>
模拟实现函数节流、防抖方法        ★★★<br>
模拟实现对象的深拷贝        ★★<br>
嵌套数组指定层次展开 flat扁平化（多种方法，至少掌握两种）★★★<br>
模拟实现 reduce 数组方法    ★<br>
模拟实现数组map方法    ★★<br>
模拟实现Array.fill()、Array.filter()    ★★<br>
模拟实现Array.find()、Array.findIndex()★★<br>
模拟实现Promise.all方法(Promise.race也需要了解)★★<br>
使用原生的JavaScript实现ajax请求（也可能让你说ajax实现原理，答案一样）★★★<br>
模拟实现构造函数new的过程（也可能让你口述new的过程，答案一样）★★★<br>
模拟实现Object.create方法    ★★<br>
模拟实现instanceof的功能        ★★★<br>
使用setTimeout实现setInterval方法 ★★<br>
实现jsonp★★★<br>
promise 实现sleep函数★★<br>
实现promise retry重试★<br>
js实现观察者模式★<br>

### 数据结构和算法


#### 排序算法（要会分析时间空间复杂度）：冒泡、选择、插入、快排    ★★★ 归并     ★<br>
二分查找（非递归递归）★★★<br>
字符串逆序（翻转整数字符串）★★★<br>
数组乱序（打乱数组，至少掌握两种方法）★★★<br>
数组去重（至少掌握两种方法）★★★<br>
两个栈来实现一个队列（两个队列实现栈可以了解一下）★<br>
#### 链表相关
入门：★★★
反转单链表<br>
未排序链表去重O（n2）<br>
排序链表去重O（n）<br>
单链表删除节点<br>
链表partition<br>
寻找链表倒数第K个节点<br>
删除链表倒数第N个节点<br>
判断链表是否为回文链表<br>
判断链表是否有环<br>
环形链表第一个入环节点<br>
两个链表的第一个公共节点<br>
#### 复杂：
合并两个排序的链表★★<br>
合并K个排序的链表★★<br>
奇偶链表★<br>
复制带随机指针的单向链表★<br>
有序链表转换二叉搜索树（BST）★<br>
二叉树展开为链表★<br>
K 个一组翻转链表★<br>
二叉树各种遍历（前中后序遍历，递归非递归，DFS,BFS）★★★<br>
二叉树遍历涉及到的一些算法题<br>
（好多题其实就是二叉树深度或者广度非递归遍历稍微改一下即可）<br>
前序和中序重建二叉树★★<br>
BST第K大的数和第K小的数★<br>
二叉树按层求和（层序遍历改进）★<br>
Z字型（之字形）遍历二叉树★<br>
二叉树深度相关<br>
二叉树深度★★★<br>
二叉树最小深度★★<br>
树找两(叶子)节点最长距离（相隔的最长路径）★<br>
判断二叉树是否为平衡二叉树★★<br>
二叉树右视图（左）★<br>
二叉树路径相关<br>
路径总和1★★★<br>
路径总和2（回溯法）★<br>
#### DP
斐波那契数列★★★<br>
最长公共子序列 LCS ★★<br>
最长上升子序列 ★★<br>
连续子数组（子串）的最大和★★<br>
硬币找零（最少硬币个数）★★<br>
0-1背包问题★<br>
完全背包问题（了解即可）★<br>
全排列（回溯法）见LeetCode 全排列1、全排列2 ★<br>

### CSS
CSS画各种图形（等腰三角形、等腰梯形、扇形、圆、半圆）    ★<br>
三列布局（至少掌握三种方法）    ★★★<br>
垂直水平居中（至少掌握三种方法）    ★★★<br>
### JS<br>
```html
/* 先将传入的指定执行环境的对象 context 取到
将需要执行的方法(调用call的对象) 作为 context 的一个属性方法fn
处理传入的参数， 并执行 context的属性方法fn， 传入处理好的参数
删除私自定义的 fn 属性
返回执行的结果 */
// 模拟 call 方法
Function.prototype.defineCall = function (context) {
    context = context || window;
    context.fn = this; //this指向 sayName函数实例
    let args = [];
    for (let i = 1; i < arguments.length; i++) { //i从1开始 
        args.push(arguments[i]);
    } //或者args = [...arguments].slice(1);
    let result = context.fn(args.join(','));
    delete context.fn;
    return result;
}
let sayName = function (age) {
    console.log('current name: ' + this.name, "current age: " + age);
}
let obj1 = {
    name: "obj's name"
}
sayName.defineCall(obj1, 22); //this指向 sayName函数实例
// current name: obj's name current age: 22


// 模拟 apply 方法
Function.prototype.defineApply = function (context, arr) {
    context = context || window;
    context.fn = this;
    let result;
    if (!arr) { // 第二个参数不传
        result = context.fn();
    } else { // 第二个参数是数组类型
        let args = [];
        for (let i = 0; i < arr.length; i++) { //i从0开始
            args.push(arr[i]);
        }
        result = context.fn(args.join(','));
    }
    delete context.fn;
    return result;
}
let obj2 = {
    name: ['Tom', 'Johy', 'Joe', 'David']
}
sayName.defineApply(obj2, [3, 4, 5, 6, 7]);
// current name: Tom,Johy,Joe,David current age: 3,4,5,6,7


//用call、apply模拟实现bind
Function.prototype.bind = function (context) {
    let self = this; // 保存函数的引用
    return function () { // 返回一个新的函数
        // console.log(arguments);
        // return self.apply(context, arguments);
        return self.call(context, arguments);
    }
};

let obj = {
    name: 'seven'
}

let func = function () {
    console.log(this.name)
}.bind(obj);
func('zhangsan', 20);
```









