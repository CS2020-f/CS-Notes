### 哈希表

哈希表通常是基于数组实现的，但是相对于数组，它存在更多优势：<br>

哈希表可以提供非常快速的插入-删除-查找操作；<br>
无论多少数据，插入和删除值都只需要非常短的时间，即O(1)的时间级。实际上，只需要几个机器指令即可完成；<br>
哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。但是相对于树来说编码要简单得多。<br>
哈希表同样存在不足之处：<br>

哈希表中的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大 ）来遍历其中的元素。<br>
通常情况下，哈希表中的key是不允许重复的，不能放置相同的key，用于保存不同的元素。<br>
哈希表是什么<br>

哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理。<br>
哈希表的结构就是数组，但它神奇之处在于对下标值的一种变换，这种变换我们可以称之为哈希函数，通过哈希函数可以获取HashCode。<br>

哈希表最后还是基于数据来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的下标值，建立字符串和下标值的对应关系。

ascll编码
也就是说：哈希表最后还是基于数据来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的下标值，建立字符串和下标值的对应关系。

1.2.哈希化的方式
为了把字符串转化为对应的下标值，需要有一套编码系统，为了方便理解我们创建这样一套编码系统：比如a为1，b为2，c为3，以此类推z为26，空格为27（不考虑大写情况）。

有了编码系统后，将字母转化为数字也有很多种方式：

方式一：数字相加。例如cats转化为数字：3+1+20+19=43，那么就把43作为cats单词的下标值储存在数组中；

但是这种方式会存在这样的问题：很多的单词按照该方式转化为数字后都是43，比如was。而在数组中一个下标值只能储存一个数据，所以该方式不合理。

方式二：幂的连乘。我们平时使用的大于10的数字，就是用幂的连乘来表示它的唯一性的。比如： 6543=6 * 103 + 5 * 102 + 4 * 10 + 3；这样单词也可以用该种方式来表示：cats = 3 * 273 + 1 * 272 + 20 * 27 + 17 =60337;
组，然
虽然该方式可以保证字符的唯一性，但是如果是较长的字符（如aaaaaaaaaa）所表示的数字就非常大，此时要求很大容量的数而其中却有许多下标值指向的是无效的数据（比如不存在zxcvvv这样的单词），造成了数组空间的浪费。

两种方案总结：

第一种方案（让数字相加求和）产生的数组下标太少；
第二种方案（与27的幂相乘求和）产生的数组下标又太多；
现在需要一种压缩方法，把幂的连乘方案系统中得到的巨大整数范围压缩到可接受的数组范围中。可以通过取余操作来实现。虽然取余操作得到的结构也有可能重复，但是可以通过其他方式解决。

哈希表的一些概念：

哈希化：将大数字转化成数组范围内下标的过程，称之为哈希化；
哈希函数：我们通常会将单词转化成大数字，把大数字进行哈希化的代码实现放在一个函数中，该函数就称为哈希函数； 
哈希表：对最终数据插入的数组进行整个结构的封装，得到的就是哈希表。
仍然需要解决的问题：

哈希化过后的下标依然可能重复，如何解决这个问题呢？这种情况称为冲突，冲突是不可避免的，我们只能解决冲突。

链地址法
解决冲突的办法是每个数组单元中存储的不再是单个数据，而是一条链条，这条链条常使用的数据结构为数组或链表，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。
插头：使用链表

开放地址法：
开放地址法的主要工作方式是寻找空白的单元格来添加重复的数据.
但是探索这个位置的方式不同, 有三种方法:
线性探测
 线性的查找空白的单元.
 删除置为null可能会影响我们之后查询其他操作, 所以通常删除一个位置的数据项时, 我们可以将它进行特殊处理(比如设置为-1).
 比较严重的问题, 就是聚集.
二次探测
, 那么线性测试就是x+1, x+2, x+3依次探测.
二次探测, 对步长做了优化, 比如从下标值x开始, x+1², x+2², x+3².
这样就可以一次性探测比较常的距离, 比避免那些聚集带来的影响.

再哈希法
生一种依赖关键字的探测序列, 而不是每个关键字都一样.
那么, 不同的关键字即使映射到相同的数组下标, 也可以使用不同的探测序列.
再哈希法的做法就是: 把关键字用另外一个哈希函数, 再做一次哈希化, 用这次哈希化的结果作为步长.
对于指定的关键字, 步长在整个探测中是不变的, 不过不同的关键字使用不同的步长.


哈希表
插入，搜索效率很高

hashmap使用与运算index=hashCode(key)&length-1
js中使用取余运算

 装填因子.
装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值.
装填因子 = 总数据项 / 哈希表长度.
开放地址法的装填因子最大是多少呢? 1, 因为它必须寻找到空白的单元才能将元素放入.
链地址法的装填因子呢? 可以大于1, 因为拉链法可以无限的延伸下去, 只要你愿意. (当然后面效率就变低了)


希表中执行插入和搜索操作可以达到O(1)的时间级，如果没有发生冲突，只需要使用一次哈希函数和数组的引用，就可以插入一个新数据项或找到一个已经存在的数据项。

如果发生冲突，存取时间就依赖后来的探测长度。一个单独的查找或插入时间与探测的长度成正比，这里还要加上哈希函数的常量时间。

平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度也越来越长。

随着填装因子变大，效率下降的情况，在不同开放地址法方案中比链地址法更严重

好的哈希   <br>
1 快速的计算   <br>
霍纳法则 减少成法   <br>

2 均匀的分布   <br>
使用常量的时候尽可能使用质数   <br>
哈希表的长度，N次幂的底数   <br>

代码

```js

<script>
    // 形式 [[[1,2],[2,3]],[]]
    function HashTable() {
        this.storage=[]
        this.count=0   //个数
        this.size=7

        HashTable.prototype.hashFun =function(str,size) {
            var hashCode=0
            //霍纳法则计算hachcode值
            //unicode编码
            for (var i=0;i<str.length;i++){
                hashCode=37*hashCode+ str.charCodeAt(i)
            }
            var index=hashCode%size
            return index
        }

        //插入&修改方法
        HashTable.prototype.put= function (key,value) {
            //1.根据key获取对应的index
            let index =this.hashFun(key,this.size)
            //2 根据index取出对应的bucket
            let bucket =this.storage[index]
            //3 判断bucket是否为null 为null就新建一个数组
            if (bucket ==null){
                bucket=[]
                this.storage[index]=bucket
            }

            //4 判断是否修改数据
            //存储数据数组 在索引0 1的位置存储key value的形式存储键值对 数组中数组中数组
            for (let i=0;i<bucket.length;i++){
                let tuple=bucket[i]; //tuple也是数组
                if(tuple[0]==key){
                    tuple[i] =value
                    return
                }
            }
            //进行添加操作
            bucket.push([key,value])
            this.count +=1
        }

        HashTable.prototype.get=function (key) {
            let index=this.hashFun(key,this.size)
            let bucket= this.storage[index]
            // 判断bucket是否为null 为null就返回null
            if (bucket ==null){
                return null
            }
            //有bucket就进行线性查找
            for (let i=0;i<bucket.length;i++){
                let tuple=bucket[i]
                if(tuple[0]==key){
                    return tuple[1]
                }
            }
            return null
        }

        HashTable.prototype.remove=function (key) {
            let index=this.hashFun(key,this.size)
            let bucket= this.storage[index]
            // 判断bucket是否为null 为null就返回null
            if (bucket ==null){
                return null
            }
            //有bucket就进行线性查找
            for (let i=0;i<bucket.length;i++){
                let tuple=bucket[i]
                if(tuple[0]==key){
                    bucket.splice(i,1)
                    this.count-=1
                    return tuple[1]
                }
            }
            return null
        }

        //判断是否为空
        HashTable.prototype.isEmpty=function () {
            return this.count ==0
        }
        //判断元素个数
        HashTable.prototype.size=function () {
            return this.count
        }
    }
    let ht=new HashTable()
    ht.put('abc',12345)
    ht.put('m',12)
    ht.put('12',123)
    console.log(ht)
    console.log(ht.get('m'))
    ht.put('m','n')
    console.log(ht.get('m'))
    ht.remove('12')
    console.log(ht.get('12'))
</script>

```


