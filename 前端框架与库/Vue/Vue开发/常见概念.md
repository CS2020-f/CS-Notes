#### 1.方法和函数
方法：method //定义在类里面      <br>
函数：function   <br>

#### 2.生命周期
一个事物从诞生到消亡的过程   <br>
hook:钩子   <br>
回调函数   <br>

#### 3.MVVM概念

#### 4.代码规范
缩进 2个空格   <br>
westrom ->setting ->Editor->Code Style ->html/js ->tab size/intent设置成2   <br>

#### 5.v-html
{{}}：会将html代码一起显示出来   <br>
v-html:会将string的html解析出来并且进行渲染   <br>
{{src}}   <br>
<h2 v-html="src"></h2>   <br>
vue p16
#### 6.v-bind:
动态绑定属性 简写 :     <br>
- 对象语法
- 数组语法
```js
<tr :class="{'类名': boolean1,'类目2'：boolean2}">Hello World</tr>   
<tr :class="['ie','rt']">Hello World</tr>   
```

#### 7.v-style
```js
<h2 :style="{'fontSize': '50px'}">Hello World</h2>
<h2 :style="{'fontSize': 50px}">Hello World</h2>  //会把50px当成变量
```
#### 8.计算属性
```js
computed:{
totalprice(){
return this.m1+' '+this.m2
}，
{{totalprice}}
//每个计算属性都包含一个getter和一个setter,一般只使用getter
fullname:{  简写    fullname()
get(){            {return 123}
return 123;
}
}
}
```
{{totalprice}}      <br>
{{totalprice}}     <br>
计算属性会进行缓存，如果多次使用时，计算属性只会调用一次

#### 9.事件监听
v-on:click 简写 @click      <br>
修饰符      <br>
.stop 阻止冒泡      <br>
```js
<div @click="divClick">
    aaa
    <button @click.stop="butClick">点我</button>
</div>  //点击按钮阻止divClick方法执行
```
.prevent 阻止默认行为
```js
<form action="baidu">
    <input type="submit" value="12" @click.prevent="">
</form>  //阻止点击默认提交手动提交
```
keyup监听某个键盘的键帽
```js
<input type="text" @keyup.enter="submit">   //监听回车键
```
#### 10.v-on 参数
@click调用methods里面的方法时，不需要参数可以不带()      <br>
1，如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去      <br>
2，如果需要同时传递某个参数，同时需要event时，可以通过$event传入事件


#### 11.对象增强写法

### 12 v-if,v-else,v-else-if
```js
 <span v-if="flag">用户账号
  <input key="username"></span>
 <span v-else>用户邮箱
  <input key="address"></span>
 <button @click="flag=!flag">切换</button>
```
切换小问题：有输入内容的情况下，切换了类型，我们会发现文字依然显示之前的输入的内容。  <br>
原因：Vue在进行DOM渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素。  <br>
解决：我们不希望Vue出现类似重复利用的问题，可以给对应的input添加key  <br>
```js
<span v-if="<input v-model="" >
<span v-if="<input v-model="" >
```


### 13 v-show,v-if
v-if当条件为false时，压根不会有对应的元素在DOM中    <br>
v-show当条件为false时，仅仅是将元素的display属性设置为none而已，DOM元素还是存在的。    <br>
如何选择：    <br>
当需要在显示与隐藏之间切片很频繁时，使用v-show    <br>
当只有一次切换时，通过使用v-if    <br>

### 14 v-for
```js
 <li v-for="(item,index) in data">
        {{index}}.{{item}}
    </li>
```
### 15 v-for绑定key
vue中列表循环需加:key="唯一标识" 唯一标识可以是item里面id index等，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM

简单地理解，无：key属性时，状态默认绑定的是位置；有：key属性时，状态根据key的属性值绑定到了相应的数组元素。

链接：https://www.jianshu.com/p/4bd5e745ce95

### 16 v-model
v-model其实是一个语法糖，它的背后本质上是包含两个操作：     <br>
1.v-bind绑定一个value属性    <br>
2.v-on指令给当前元素绑定input事件    <br>
```js
<input type="text" v-model="message">
等同于
<input type="text" v-bind:value="message" v-on:input="message = $event.target.value">
```
$event.target.value    <br>
触发input事件时，$event是当前的事件对象，$event.target.value指的是当前input的值    <br>

修饰符
- lazy  lazy修饰符可以让数据在失去焦点或者回车时才会更新
- number  number修饰符可以让在输入框中输入的内容自动转成数字类型
- trim  trim修饰符可以过滤内容左右两边的空格
```js
v-model.trim="message"
```
v-model结合radio 多个单选框


```js
v-for="(item,index) in array" :class="{active:currentIndex===index}" @click="change(index)"
{{item.price | showPrice}}
change(index){this.currentIndex=index}
```
### 过滤器
```js
filters:{
   showPrice(price){return '￥'+price.toFixed(2);}
}
```

P43

### 16 数组中哪些方法是响应式的
push    <br>
pop :删除数组最后一个元素    <br>
shift: 删除数组第一个元素    <br>
unshift: 在数组前面添加元素    <br>
splice: 删除元素/插入元素/替换元素    <br>
splice(index,len):从第index那个元素起删除len个元素 只传一个index就删除后面所有的元素    <br>
splice(index,len,'a','b','c'): 替换    <br>
splice(index,0,'a','b','c'): 插入    <br>
sort: 排序    <br>
reverse(): 反转

注意：通过索引修改数组中的值不会渲染dom不是响应式的
array.splice(0,1,'a'): 通过索引修改第一个元素



vue P38
vue P52
### 组件
提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用    <br>
任何的应用都会被抽象成一颗组件树    <br>

注册组件基本步骤
- 创建组件构造器对象
- 注册组件
- 使用组件
1.调用Vue.extend()方法创建组件构造器  <br>
调用Vue.extend()创建的是一个组件构造器。   <br>
通常在创建组件构造器时，传入template代表我们自定义组件的模板。  <br>
该模板就是在使用到组件的地方，要显示的HTML代码。  <br>

2.调用Vue.component()方法注册组件  <br>
需要传递两个参数：1、注册组件的标签名 2、组件构造器  <br>
3.再Vue实例的范围内使用组件  <br>
#### 全局组件和局部组件
全局组件：可以在Vue多个实例下使用
局部组件：在某个Vue实例里创建
components:{
cpn:cpn
}
开发中一般局部组件用的多
#### 父组件和子组件
可以在父组件中注册子组件//Vue实例也可以看成一个组件

#### 组件的语法糖注册方式

```js
- 注册全局组件
Vue.component(组件标签名,{
    template:'
    <div>
   </div>
    '
})
- 注册局部组件
components:{
cpn:{
 template:'
    <div>
   </div>
    '
}
- 创建组件构造器
const myComponent = Vue.extend({
 template:'
    <div>
   </div>
    '
})
注册组件
Vue.component('my-con',myComponent);
```
#### 组件模板分离写法
Vue提供了两种方案来定义HTML模块内容：  <br>
使用<script>标签  <br>
使用<template>标签  <br>
```js
- 注册局部组件
    
<template id="myCnp">
    div>
   </div>
</template> 
components:{
cpn:{
 template:'#myCnp'
}

```

#### 为什么组件data必须是函数
组件是一个单独功能模块的封装，不能直接访问Vue实例数据
data必须是一个函数，并且这个函数返回一个对象，数据保存在对象里面
一个组件可以有多个组件实例对象
在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响
内存地址不一样

### 父子组件间通信
1.通过props(properties)向子组件传递数据  <br>
2.通过事件(自定义事件$emit)向父组件发送消息  <br>
注意：v-bind:不支持驼峰命名，
需要把myName->my-name
props:[`myName`]
:my-name="父组件值"

子组件发生点击事件，父组件需要知道点击那个  <br>
在子组件中，通过$emit('事件',item)来触发事件。  <br>
在父组件中，通过v-on来监听子组件事件。  <br>

props的值有两种方式：  <br>
方式一：字符串数组，数组中的字符串就是传递时的名称。  <br>
方式二：对象，对象可以设置传递时的类型，也可以设置默认值等。  <br>
```js
- 字符串数组
<cpn :message="message1"></cpn>
<template id="myCnp">
    div>
   </div>
</template> 
components:{
data:{
message1:"123"
}
cpn:{
 template:'#myCnp',
 props: ['message']
}

```
- 对象类型
需要对props进行类型等验证时，  <br>
验证都支持哪些数据类型呢  <br>
String
Number
Boolean
Array
Object
Date
Function
Symbol
```js
props:{
//多个可能的类型
propa:[String,Number]，
```

自定义事件的流程：  <br>
在子组件中，通过$emit()来触发事件。  <br>
在父组件中，通过v-on来监听子组件事件。  <br>
```js
父组件中
<cpn @increate="change"></cpn>
子组件中
increate()
{this.counter++;
this.$emit('increate',this.counter)
}
//通过@increate监听事件
```
v-on:click   //监听click事件  <br>
v-on:increate/@increate    //监听自定义事件increate  <br>

### 父子组件之间访问方式
父组件访问子组件：使用$children或$refs  <br>
子组件访问父组件：使用$parent  <br>
this.$children是一个数组类型，它包含所有子组件对象。  <br>
遍历，访问子组件的属性和方法  <br>
- 一般使用$refs
- 子访问父组件
this.$parent  开发中不建议这么做




### Vue中 $ref 的用法
vm.$refs 一个对象，持有已注册过 ref 的所有子组件（或HTML元素）  <br>
使用：在 HTML元素 中，添加ref属性，然后在JS中通过vm.$refs.属性来获取  <br>
注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods  <br>
```js
<div id="app">
<h1 ref="h1Ele">这是H1</h1>

<button @click="getref">获取H1元素</button>
</div>
获取注册过 ref 的所有组件或元素
methods: {
getref() {
// 表示从 $refs对象 中, 获取 ref 属性值为: h1ele DOM元素或组件
console.log(this.$refs.h1Ele.innerText);
this.$refs.h1ele.style.color = 'red';// 修改html样式
console.log(this.$refs.ho.msg);// 获取组件数据
console.log(this.$refs.ho.test);// 获取组件的方法
}
}
```



### 插槽 slot
组件的插槽也是为了让我们封装的组件更加具有扩展性。  <br>
让使用者可以决定组件内部的一些内容到底展示什么  <br>
在子组件中，使用特殊的元素<slot>就可以为子组件开启一个插槽。  <br>
该插槽插入什么内容取决于父组件如何使用。  <br>
    具名插槽
```js
 <slot name="left">12</slot>   
    使用
  <span slot="">34</span>
```
    作用域插槽
    父组件替换插槽的标签，但是内容由子组件来提供

### 前端模块化


vue P74 P75之后补上

-》P91
vue-cli

### vue-router
路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动。  <br>

### 后端渲染和前端渲染
后端渲染：  <br>
JSP  <br>
后端路由：  <br>
后端处理url和和页面之间的映射关系  <br>

前后端分离  <br>
后端只负责提供数据，不负责任何阶段的内容  <br>

前端渲染：  <br>
浏览器中显示网页大部分中内容，都是由前端写的js代码在浏览器中执行，最终渲染的网页  <br>

单页面富应用阶段:  <br>
其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由.  <br>
也就是前端来维护一套路由规则.  <br>
前端路由的核心是什么呢？  <br>
改变URL，但是页面不进行整体的刷新。  <br>

### URL的hah 和html5的history
URL的hash  <br>
URL的hash也就是锚点(#), 本质上是改变window.location的href属性.  <br>
我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新  <br>

HTML5的history模式：pushState 
压栈  改变href, 但是页面不发生刷新  <br>
HTML5的history模式：replaceState  <br>
替换上一个url  <br>
HTML5的history模式：go  <br>
因为 history.back() 等价于 history.go(-1)  <br>//移除栈顶元素
history.forward() 则等价于 history.go(1)  <br>
这三个接口等同于浏览器界面的前进后退。  <br>
URL的hash
HTML5的history
默认情况下, 路径的改变使用的URL的hash.
如果希望使用HTML5的history模式, 非常简单, 进行如下配置即可:
```js
const router = new VueRouter({
  routes,
  mode: 'history'
});
```

### router-link router-view
<router-link>: 该标签是一个vue-router中已经内置的组件, 它会被渲染成一个<a>标签.  <br>
<router-view>: 该标签会根据当前的路径, 动态渲染出不同的组件.  <br>
网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等会和<router-view>处于同一个等级.  <br>
在路由切换时, 切换的是<router-view>挂载的组件, 其他内容不会发生改变  <br>
    
### 代码跳转路由
Vue-router给每个组件都添加一个$router
```js
data(){return {
$router: ""
}}
```
$router就是new Router()对象
```js
this.$router.push('/home')
this.$router.place('/home')
```
this.$route           <br>
那个路由活跃就是那个路由   <br>
This.$route.params.userid 获取id
### 动态路由
```js
<router-link :to="'/user/'+userid">用户</router-link>
  {
            path: '/user/:id',
            component: ShopNumBing,       
          },
 This.$route.params.userid 获取id
 ```
 

 
 ### 懒加载
 当打包构建应用时，Javascript 包会变得非常大，影响页面加载。          <br>
如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了          <br>

路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块.          <br>
只有在这个路由被访问到的时候, 才加载对应的组件          <br>
```js
const Home =()=>import("./");
```
一个懒加载路由，打包之后js下就多一个js文件

### 嵌套路由


在home页面中, 我们希望通过/home/news和/home/message访问一些内容.          <br>
一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件.          <br>

实现嵌套路由有两个步骤:          <br>
创建对应的子组件, 并且在路由映射中配置对应的子路由.          <br>
在组件内部使用<router-view>标签.          <br>

### vue-router 参数传递
传递参数主要有两种类型: params和query         <br>
1 动态路由         <br>
params的类型:         <br>
配置路由格式: /router/:id         <br>
传递的方式: 在path后面跟上对应的值         <br>
传递后形成的路径: /router/123, /router/abc         <br>
```js
取值：
 This.$route.params.userid
 ```
 2 
query的类型:         <br>
配置路由格式: /router, 也就是普通配置        <br>
传递的方式: 对象中使用query的key作为传递方式        <br>
传递后形成的路径: /router?id=123, /router?id=abc        <br>
```js
1,
this.$router.push('/user/'+userid)
this.$router.push({path: `/TeamremuDetail/${item.id}/02`})
${}  插入变量
2,
this.$router.push({name:'ItemDetail', query: {id:item.id,num:item.num,status:item.dishesStatus}})

this.$router.push({
  path:'/profile',
  query: {
    id: id,
    name: name
  }
})
取值
 This.$route.query.id
```

### vue-router router和route
router为VueRouter的实例，相当于一个全局的路由器对象，里面含有很多属性和子对象，例如history对象..经常用的跳转链接就可以用this.$router.push，和router-link跳转一样        <br>
this.$router.push会往history栈中添加一个新的记录        <br>
route相当于当前正在跳转(处于活跃)的路由对象。。可以从里面获取name,path,params,query等        <br>

所有的组件都继承Vue类的原型        <br>


### 组件使用
两种写法，默认第二种        <br>
1 <HomeNew></HomeNew>            <br>
2 <home-new></home-new>        <br>

### 全局导航守卫
vue-router提供的导航守卫主要用来监听监听路由的进入和离开的.        <br>
vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发.        <br>

meta: 元数据(描述数据的数据)
```js
export type NavigationGuard<V extends Vue = Vue> = (
  to: Route,
  from: Route,
  next: NavigationGuardNext<V>
) => any

//路由跳转
router.beforeEach((to, from, next) => {
//从from跳转到to
  next();
})
```
导航钩子的三个参数解析:        <br>
to: 即将要进入的目标的路由对象.        <br>
from: 当前导航即将要离开的路由对象.        <br>
next: 调用该方法后, 才能进入下一个钩子.        <br>

P114


