#### 1.方法和函数
方法：method //定义在类里面      <br>
函数：function   <br>

#### 2.生命周期
一个事物从诞生到消亡的过程   <br>
hook:钩子   <br>
回调函数   <br>

#### 3.MVVM概念

#### 4.代码规范
缩进 2个空格   <br>
westrom ->setting ->Editor->Code Style ->html/js ->tab size/intent设置成2   <br>

#### 5.v-html
{{}}：会将html代码一起显示出来   <br>
v-html:会将string的html解析出来并且进行渲染   <br>
{{src}}   <br>
<h2 v-html="src"></h2>   <br>
vue p16
#### 6.v-bind:
动态绑定属性 简写 :     <br>
- 对象语法
- 数组语法
```js
<tr :class="{'类名': boolean1,'类目2'：boolean2}">Hello World</tr>   
<tr :class="['ie','rt']">Hello World</tr>   
```

#### 7.v-style
```js
<h2 :style="{'fontSize': '50px'}">Hello World</h2>
<h2 :style="{'fontSize': 50px}">Hello World</h2>  //会把50px当成变量
```
#### 8.计算属性
```js
computed:{
totalprice(){
return this.m1+' '+this.m2
}，
{{totalprice}}
//每个计算属性都包含一个getter和一个setter,一般只使用getter
fullname:{  简写    fullname()
get(){            {return 123}
return 123;
}
}
}
```
{{totalprice}}      <br>
{{totalprice}}     <br>
计算属性会进行缓存，如果多次使用时，计算属性只会调用一次

#### 9.事件监听
v-on:click 简写 @click      <br>
修饰符      <br>
.stop 阻止冒泡      <br>
```js
<div @click="divClick">
    aaa
    <button @click.stop="butClick">点我</button>
</div>  //点击按钮阻止divClick方法执行
```
.prevent 阻止默认行为
```js
<form action="baidu">
    <input type="submit" value="12" @click.prevent="">
</form>  //阻止点击默认提交手动提交
```
keyup监听某个键盘的键帽
```js
<input type="text" @keyup.enter="submit">   //监听回车键
```
#### 10.v-on 参数
@click调用methods里面的方法时，不需要参数可以不带()      <br>
1，如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去      <br>
2，如果需要同时传递某个参数，同时需要event时，可以通过$event传入事件


#### 11.对象增强写法

### 12 v-if,v-else,v-else-if
```js
 <span v-if="flag">用户账号
  <input key="username"></span>
 <span v-else>用户邮箱
  <input key="address"></span>
 <button @click="flag=!flag">切换</button>
```
切换小问题：有输入内容的情况下，切换了类型，我们会发现文字依然显示之前的输入的内容。  <br>
原因：Vue在进行DOM渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素。  <br>
解决：我们不希望Vue出现类似重复利用的问题，可以给对应的input添加key  <br>
```js
<span v-if="<input v-model="" >
<span v-if="<input v-model="" >
```


### 13 v-show,v-if
v-if当条件为false时，压根不会有对应的元素在DOM中    <br>
v-show当条件为false时，仅仅是将元素的display属性设置为none而已，DOM元素还是存在的。    <br>
如何选择：    <br>
当需要在显示与隐藏之间切片很频繁时，使用v-show    <br>
当只有一次切换时，通过使用v-if    <br>

### 14 v-for
```js
 <li v-for="(item,index) in data">
        {{index}}.{{item}}
    </li>
```
### 15 v-for绑定key
vue中列表循环需加:key="唯一标识" 唯一标识可以是item里面id index等，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM

简单地理解，无：key属性时，状态默认绑定的是位置；有：key属性时，状态根据key的属性值绑定到了相应的数组元素。

链接：https://www.jianshu.com/p/4bd5e745ce95

### 16 v-model
v-model其实是一个语法糖，它的背后本质上是包含两个操作：     <br>
1.v-bind绑定一个value属性    <br>
2.v-on指令给当前元素绑定input事件    <br>
```js
<input type="text" v-model="message">
等同于
<input type="text" v-bind:value="message" v-on:input="message = $event.target.value">
```
$event.target.value    <br>
触发input事件时，$event是当前的事件对象，$event.target.value指的是当前input的值    <br>

修饰符
- lazy  lazy修饰符可以让数据在失去焦点或者回车时才会更新
- number  number修饰符可以让在输入框中输入的内容自动转成数字类型
- trim  trim修饰符可以过滤内容左右两边的空格
```js
v-model.trim="message"
```

vue P38
vue P52
### 组件
提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用    <br>
任何的应用都会被抽象成一颗组件树    <br>

注册组件基本步骤
- 创建组件构造器对象
- 注册组件
- 使用组件
1.调用Vue.extend()方法创建组件构造器  <br>
调用Vue.extend()创建的是一个组件构造器。   <br>
通常在创建组件构造器时，传入template代表我们自定义组件的模板。  <br>
该模板就是在使用到组件的地方，要显示的HTML代码。  <br>

2.调用Vue.component()方法注册组件  <br>
需要传递两个参数：1、注册组件的标签名 2、组件构造器  <br>
3.再Vue实例的范围内使用组件  <br>
#### 全局组件和局部组件
全局组件：可以在Vue多个实例下使用
局部组件：在某个Vue实例里创建
components:{
cpn:cpn
}
开发中一般局部组件用的多
#### 父组件和子组件
可以在父组件中注册子组件//Vue实例也可以看成一个组件

#### 组件的语法糖注册方式

```js
- 注册全局组件
Vue.component(组件标签名,{
    template:'
    <div>
   </div>
    '
})
- 注册局部组件
components:{
cpn:{
 template:'
    <div>
   </div>
    '
}
- 创建组件构造器
const myComponent = Vue.extend({
 template:'
    <div>
   </div>
    '
})
注册组件
Vue.component('my-con',myComponent);
```
#### 组件模板分离写法
Vue提供了两种方案来定义HTML模块内容：  <br>
使用<script>标签  <br>
使用<template>标签  <br>
```js
- 注册局部组件
    
<template id="myCnp">
    div>
   </div>
</template> 
components:{
cpn:{
 template:'#myCnp'
}

```

#### 为什么组件data必须是函数
组件是一个单独功能模块的封装，不能直接访问Vue实例数据
data必须是一个函数，并且这个函数返回一个对象，数据保存在对象里面
一个组件可以有多个组件实例对象
在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响
内存地址不一样

### 父子组件间通信
1.通过props(properties)向子组件传递数据  <br>
2.通过事件(自定义事件$emit)向父组件发送消息  <br>
注意：v-bind:不支持驼峰命名，
需要把myName->my-name
props:[`myName`]
:my-name="父组件值"

子组件发生点击事件，父组件需要知道点击那个  <br>
在子组件中，通过$emit('事件',item)来触发事件。  <br>
在父组件中，通过v-on来监听子组件事件。  <br>

props的值有两种方式：  <br>
方式一：字符串数组，数组中的字符串就是传递时的名称。  <br>
方式二：对象，对象可以设置传递时的类型，也可以设置默认值等。  <br>
```js
- 字符串数组
<cpn :message="message1"></cpn>
<template id="myCnp">
    div>
   </div>
</template> 
components:{
data:{
message1:"123"
}
cpn:{
 template:'#myCnp',
 props: ['message']
}

```
- 对象类型
需要对props进行类型等验证时，  <br>
验证都支持哪些数据类型呢  <br>
String
Number
Boolean
Array
Object
Date
Function
Symbol
```js
props:{
//多个可能的类型
propa:[String,Number]，
```

自定义事件的流程：  <br>
在子组件中，通过$emit()来触发事件。  <br>
在父组件中，通过v-on来监听子组件事件。  <br>
```js
<cpn @increate="change"></cpn>
子组件中
increate()
{this.counter++;
this.$emit('increate',this.counter)
}
//通过@increate监听事件
```

### Vue中 $ref 的用法
vm.$refs 一个对象，持有已注册过 ref 的所有子组件（或HTML元素）  <br>
使用：在 HTML元素 中，添加ref属性，然后在JS中通过vm.$refs.属性来获取  <br>
注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods  <br>
```js
<div id="app">
<h1 ref="h1Ele">这是H1</h1>

<button @click="getref">获取H1元素</button>
</div>
获取注册过 ref 的所有组件或元素
methods: {
getref() {
// 表示从 $refs对象 中, 获取 ref 属性值为: h1ele DOM元素或组件
console.log(this.$refs.h1Ele.innerText);
this.$refs.h1ele.style.color = 'red';// 修改html样式
console.log(this.$refs.ho.msg);// 获取组件数据
console.log(this.$refs.ho.test);// 获取组件的方法
}
}
```

### 父子组件通信
父组件访问子组件：使用$children或$refs  <br>
子组件访问父组件：使用$parent  <br>

### 插槽 slot
在子组件中，使用特殊的元素<slot>就可以为子组件开启一个插槽。  <br>
该插槽插入什么内容取决于父组件如何使用。  <br>




vue P64
